-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Backend for the persistent library using sqlite3.
--   
--   This package includes a thin sqlite3 wrapper based on the
--   direct-sqlite package, as well as the entire C library, so there are
--   no system dependencies.
@package persistent-sqlite
@version 2.13.3.0


-- | Utterly unsafe internals of the <a>Database.Sqlite</a> module. Useful
--   for people who want access to the SQLite database pointer to manually
--   call SQLite API functions via the FFI.
--   
--   Types and functions in this module are *NOT* covered by the PVP and
--   may change breakingly in any future version of the package.
module Database.Sqlite.Internal

-- | SQLite connection type, consist of an IORef tracking whether the
--   connection has been closed and the raw SQLite C API pointer, wrapped
--   in a 'Connection'' newtype.
data Connection
Connection :: !IORef Bool -> Connection' -> Connection

-- | Newtype wrapping SQLite C API pointer for a database connection.
newtype Connection'
Connection' :: Ptr () -> Connection'

-- | Newtype wrapping SQLite C API pointer for a prepared statement.
newtype Statement
Statement :: Ptr () -> Statement


-- | A port of the direct-sqlite package for dealing directly with
--   <a>PersistValue</a>s.
module Database.Sqlite

-- | SQLite connection type, consist of an IORef tracking whether the
--   connection has been closed and the raw SQLite C API pointer, wrapped
--   in a 'Connection'' newtype.
data Connection

-- | Newtype wrapping SQLite C API pointer for a prepared statement.
data Statement
data Error
ErrorOK :: Error
ErrorError :: Error
ErrorInternal :: Error
ErrorPermission :: Error
ErrorAbort :: Error
ErrorBusy :: Error
ErrorLocked :: Error
ErrorNoMemory :: Error
ErrorReadOnly :: Error
ErrorInterrupt :: Error
ErrorIO :: Error
ErrorNotFound :: Error
ErrorCorrupt :: Error
ErrorFull :: Error
ErrorCan'tOpen :: Error
ErrorProtocol :: Error
ErrorEmpty :: Error
ErrorSchema :: Error
ErrorTooBig :: Error
ErrorConstraint :: Error
ErrorMismatch :: Error
ErrorMisuse :: Error
ErrorNoLargeFileSupport :: Error
ErrorAuthorization :: Error
ErrorFormat :: Error
ErrorRange :: Error
ErrorNotAConnection :: Error
ErrorRow :: Error
ErrorDone :: Error

-- | A custom exception type to make it easier to catch exceptions.
data SqliteException
SqliteException :: !Error -> !Text -> !Text -> SqliteException
[seError] :: SqliteException -> !Error
[seFunctionName] :: SqliteException -> !Text
[seDetails] :: SqliteException -> !Text
data StepResult
Row :: StepResult
Done :: StepResult

-- | Configuration option for SQLite to be used together with the
--   <a>config</a> function.
data Config

-- | A function to be used for logging
ConfigLogFn :: LogFunction -> Config

data LogFunction

-- | Return type of the <a>status</a> function
data SqliteStatus
SqliteStatus :: Maybe Int -> Maybe Int -> SqliteStatus

-- | The current value of the parameter. Some parameters do not record
--   current value.
[sqliteStatusCurrent] :: SqliteStatus -> Maybe Int

-- | The highest recorded value. Some parameters do not record the highest
--   value.
[sqliteStatusHighwater] :: SqliteStatus -> Maybe Int

-- | Run-time status parameter that can be returned by <a>status</a>
--   function.
data SqliteStatusVerb

-- | This parameter is the current amount of memory checked out using
--   sqlite3_malloc(), either directly or indirectly. The figure includes
--   calls made to sqlite3_malloc() by the application and internal memory
--   usage by the SQLite library. Scratch memory controlled by
--   SQLITE_CONFIG_SCRATCH and auxiliary page-cache memory controlled by
--   SQLITE_CONFIG_PAGECACHE is not included in this parameter. The amount
--   returned is the sum of the allocation sizes as reported by the xSize
--   method in sqlite3_mem_methods.
SqliteStatusMemoryUsed :: SqliteStatusVerb

-- | This parameter returns the number of pages used out of the pagecache
--   memory allocator that was configured using SQLITE_CONFIG_PAGECACHE.
--   The value returned is in pages, not in bytes.
SqliteStatusPagecacheUsed :: SqliteStatusVerb

-- | This parameter returns the number of bytes of page cache allocation
--   which could not be satisfied by the SQLITE_CONFIG_PAGECACHE buffer and
--   where forced to overflow to sqlite3_malloc(). The returned value
--   includes allocations that overflowed because they where too large
--   (they were larger than the "sz" parameter to SQLITE_CONFIG_PAGECACHE)
--   and allocations that overflowed because no space was left in the page
--   cache.
SqliteStatusPagecacheOverflow :: SqliteStatusVerb

-- | This parameter returns the number of allocations used out of the
--   scratch memory allocator configured using SQLITE_CONFIG_SCRATCH. The
--   value returned is in allocations, not in bytes. Since a single thread
--   may only have one scratch allocation outstanding at time, this
--   parameter also reports the number of threads using scratch memory at
--   the same time.
SqliteStatusScratchUsed :: SqliteStatusVerb

-- | This parameter returns the number of bytes of scratch memory
--   allocation which could not be satisfied by the SQLITE_CONFIG_SCRATCH
--   buffer and where forced to overflow to sqlite3_malloc(). The values
--   returned include overflows because the requested allocation was too
--   larger (that is, because the requested allocation was larger than the
--   "sz" parameter to SQLITE_CONFIG_SCRATCH) and because no scratch buffer
--   slots were available.
SqliteStatusScratchOverflow :: SqliteStatusVerb

-- | This parameter records the largest memory allocation request handed to
--   sqlite3_malloc() or sqlite3_realloc() (or their internal equivalents).
--   Only the value returned in <a>sqliteStatusHighwater</a> field of
--   <a>SqliteStatus</a> record is of interest. The value written into the
--   <a>sqliteStatusCurrent</a> field is Nothing.
SqliteStatusMallocSize :: SqliteStatusVerb

-- | This parameter records the largest memory allocation request handed to
--   pagecache memory allocator. Only the value returned in the
--   <a>sqliteStatusHighwater</a> field of <a>SqliteStatus</a> record is of
--   interest. The value written into the <a>sqliteStatusCurrent</a> field
--   is Nothing.
SqliteStatusPagecacheSize :: SqliteStatusVerb

-- | This parameter records the largest memory allocation request handed to
--   scratch memory allocator. Only the value returned in the
--   <a>sqliteStatusHighwater</a> field of <a>SqliteStatus</a> record is of
--   interest. The value written into the <a>sqliteStatusCurrent</a> field
--   is Nothing.
SqliteStatusScratchSize :: SqliteStatusVerb

-- | This parameter records the number of separate memory allocations
--   currently checked out.
SqliteStatusMallocCount :: SqliteStatusVerb
open :: Text -> IO Connection

-- | Like <a>open</a>, but accepts a <tt>ByteString</tt> instead of a
--   <a>Text</a>.
open' :: ByteString -> IO Connection
close :: Connection -> IO ()
prepare :: Connection -> Text -> IO Statement

-- | Execute a database statement. It's recommended to use <a>stepConn</a>
--   instead, because it gives better error messages.
step :: Statement -> IO StepResult

-- | Execute a database statement. This function uses the <a>Connection</a>
--   passed to it to give better error messages than <a>step</a>.
stepConn :: Connection -> Statement -> IO StepResult
reset :: Connection -> Statement -> IO ()
finalize :: Statement -> IO ()
bindBlob :: Statement -> Int -> ByteString -> IO ()
bindDouble :: Statement -> Int -> Double -> IO ()
bindInt :: Statement -> Int -> Int -> IO ()
bindInt64 :: Statement -> Int -> Int64 -> IO ()
bindNull :: Statement -> Int -> IO ()
bindText :: Statement -> Int -> Text -> IO ()
bind :: Statement -> [PersistValue] -> IO ()
column :: Statement -> Int -> IO PersistValue
columns :: Statement -> IO [PersistValue]
changes :: Connection -> IO Int64

-- | Wraps a given function to a <a>LogFunction</a> to be further used with
--   <a>ConfigLogFn</a>. First argument of given function will take error
--   code, second - log message. Returned value should be released with
--   <a>freeLogFunction</a> when no longer required.
mkLogFunction :: (Int -> String -> IO ()) -> IO LogFunction

-- | Releases a native FunPtr for the <a>LogFunction</a>.
freeLogFunction :: LogFunction -> IO ()

-- | Sets SQLite global configuration parameter. See SQLite documentation
--   for the <a>sqlite3_config</a> function. In short, this must be called
--   prior to any other SQLite function if you want the call to succeed.
config :: Config -> IO ()

-- | Retrieves runtime status information about the performance of SQLite,
--   and optionally resets various highwater marks. The first argument is a
--   status parameter to measure, the second is reset flag. If reset flag
--   is True then the highest recorded value is reset after being returned
--   from this function.
status :: SqliteStatusVerb -> Bool -> IO SqliteStatus

-- | Sets and/or queries the soft limit on the amount of heap memory that
--   may be allocated by SQLite. If the argument is zero then the soft heap
--   limit is disabled. If the argument is negative then no change is made
--   to the soft heap limit. Hence, the current size of the soft heap limit
--   can be determined by invoking this function with a negative argument.
softHeapLimit :: Int64 -> IO Int64
enableExtendedResultCodes :: Connection -> IO ()
disableExtendedResultCodes :: Connection -> IO ()
instance GHC.Show.Show Database.Sqlite.Error
instance GHC.Classes.Eq Database.Sqlite.Error
instance GHC.Show.Show Database.Sqlite.StepResult
instance GHC.Classes.Eq Database.Sqlite.StepResult
instance GHC.Show.Show Database.Sqlite.ColumnType
instance GHC.Classes.Eq Database.Sqlite.ColumnType
instance GHC.Show.Show Database.Sqlite.SqliteStatus
instance GHC.Classes.Eq Database.Sqlite.SqliteStatus
instance GHC.Show.Show Database.Sqlite.SqliteException
instance GHC.Exception.Type.Exception Database.Sqlite.SqliteException


-- | A sqlite backend for persistent.
--   
--   Note: If you prepend <tt>WAL=off </tt> to your connection string, it
--   will disable the write-ahead log. This functionality is now deprecated
--   in favour of using SqliteConnectionInfo.
module Database.Persist.Sqlite

-- | Run the given action with a connection pool.
--   
--   Like <a>createSqlitePool</a>, this should not be used with
--   <tt>:memory:</tt>.
withSqlitePool :: (MonadUnliftIO m, MonadLoggerIO m) => Text -> Int -> (Pool SqlBackend -> m a) -> m a

-- | Run the given action with a connection pool.
--   
--   Like <a>createSqlitePool</a>, this should not be used with
--   <tt>:memory:</tt>.
withSqlitePoolInfo :: (MonadUnliftIO m, MonadLoggerIO m) => SqliteConnectionInfo -> Int -> (Pool SqlBackend -> m a) -> m a
withSqliteConn :: (MonadUnliftIO m, MonadLoggerIO m) => Text -> (SqlBackend -> m a) -> m a

withSqliteConnInfo :: (MonadUnliftIO m, MonadLoggerIO m) => SqliteConnectionInfo -> (SqlBackend -> m a) -> m a

-- | Create a pool of SQLite connections.
--   
--   Note that this should not be used with the <tt>:memory:</tt>
--   connection string, as the pool will regularly remove connections,
--   destroying your database. Instead, use <a>withSqliteConn</a>.
createSqlitePool :: (MonadLoggerIO m, MonadUnliftIO m) => Text -> Int -> m (Pool SqlBackend)

-- | Create a pool of SQLite connections.
--   
--   Note that this should not be used with the <tt>:memory:</tt>
--   connection string, as the pool will regularly remove connections,
--   destroying your database. Instead, use <a>withSqliteConn</a>.
createSqlitePoolFromInfo :: (MonadLoggerIO m, MonadUnliftIO m) => SqliteConnectionInfo -> Int -> m (Pool SqlBackend)

-- | Create a pool of SQLite connections.
createSqlitePoolWithConfig :: (MonadUnliftIO m, MonadLoggerIO m) => Text -> ConnectionPoolConfig -> m (Pool SqlBackend)

-- | Information required to setup a connection pool.
data SqliteConf
SqliteConf :: Text -> Int -> SqliteConf
[sqlDatabase] :: SqliteConf -> Text
[sqlPoolSize] :: SqliteConf -> Int
SqliteConfInfo :: SqliteConnectionInfo -> Int -> SqliteConf
[sqlConnInfo] :: SqliteConf -> SqliteConnectionInfo
[sqlPoolSize] :: SqliteConf -> Int

-- | Information required to connect to a sqlite database. We export lenses
--   instead of fields to avoid being limited to the current
--   implementation.
data SqliteConnectionInfo

-- | Creates a SqliteConnectionInfo from a connection string, with the
--   default settings.
mkSqliteConnectionInfo :: Text -> SqliteConnectionInfo
sqlConnectionStr :: Lens' SqliteConnectionInfo Text
walEnabled :: Lens' SqliteConnectionInfo Bool
fkEnabled :: Lens' SqliteConnectionInfo Bool
extraPragmas :: Lens' SqliteConnectionInfo [Text]

-- | A convenience helper which creates a new database connection and runs
--   the given block, handling <tt>MonadResource</tt> and
--   <tt>MonadLogger</tt> requirements. Note that all log messages are
--   discarded.
runSqlite :: MonadUnliftIO m => Text -> ReaderT SqlBackend (NoLoggingT (ResourceT m)) a -> m a

-- | A convenience helper which creates a new database connection and runs
--   the given block, handling <tt>MonadResource</tt> and
--   <tt>MonadLogger</tt> requirements. Note that all log messages are
--   discarded.
runSqliteInfo :: MonadUnliftIO m => SqliteConnectionInfo -> ReaderT SqlBackend (NoLoggingT (ResourceT m)) a -> m a

-- | Wrap up a raw <a>Connection</a> as a Persistent SQL
--   <tt>Connection</tt>.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   {-# LANGUAGE GADTs #-}
--   {-# LANGUAGE ScopedTypeVariables #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE MultiParamTypeClasses #-}
--   {-# LANGUAGE TypeFamilies #-}
--   {-# LANGUAGE TemplateHaskell #-}
--   {-# LANGUAGE QuasiQuotes #-}
--   {-# LANGUAGE GeneralizedNewtypeDeriving #-}
--   
--   import Control.Monad.IO.Class  (liftIO)
--   import Database.Persist
--   import Database.Sqlite
--   import Database.Persist.Sqlite
--   import Database.Persist.TH
--   
--   share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
--   Person
--     name String
--     age Int Maybe
--     deriving Show
--   |]
--   
--   main :: IO ()
--   main = do
--     conn &lt;- open "/home/sibi/test.db"
--     (backend :: SqlBackend) &lt;- wrapConnection conn (\_ _ _ _ -&gt; return ())
--     flip runSqlPersistM backend $ do
--            runMigration migrateAll
--            insert_ $ Person "John doe" $ Just 35
--            insert_ $ Person "Hema" $ Just 36
--            (pers :: [Entity Person]) &lt;- selectList [] []
--            liftIO $ print pers
--     close' backend
--   </pre>
--   
--   On executing it, you get this output:
--   
--   <pre>
--   Migrating: CREATE TABLE "person"("id" INTEGER PRIMARY KEY,"name" VARCHAR NOT NULL,"age" INTEGER NULL)
--   [Entity {entityKey = PersonKey {unPersonKey = SqlBackendKey {unSqlBackendKey = 1}}, entityVal = Person {personName = "John doe", personAge = Just 35}},Entity {entityKey = PersonKey {unPersonKey = SqlBackendKey {unSqlBackendKey = 2}}, entityVal = Person {personName = "Hema", personAge = Just 36}}]
--   </pre>
wrapConnection :: Connection -> LogFunc -> IO SqlBackend

-- | Wrap up a raw <a>Connection</a> as a Persistent SQL
--   <tt>Connection</tt>, allowing full control over WAL and FK
--   constraints.
wrapConnectionInfo :: SqliteConnectionInfo -> Connection -> LogFunc -> IO SqlBackend

-- | Mock a migration even when the database is not present. This function
--   performs the same functionality of <a>printMigration</a> with the
--   difference that an actual database isn't needed for it.
mockMigration :: Migration -> IO ()

-- | Retry if a Busy is thrown, following an exponential backoff strategy.
retryOnBusy :: (MonadUnliftIO m, MonadLoggerIO m) => m a -> m a

-- | Wait until some noop action on the database does not return an
--   <a>ErrorBusy</a>. See <a>retryOnBusy</a>.
waitForDatabase :: (MonadUnliftIO m, MonadLoggerIO m, BackendCompatible SqlBackend backend) => ReaderT backend m ()

-- | Data type for reporting foreign key violations using
--   <a>checkForeignKeys</a>.
data ForeignKeyViolation
ForeignKeyViolation :: Text -> Text -> Int64 -> ForeignKeyViolation

-- | The table of the violated constraint
[foreignKeyTable] :: ForeignKeyViolation -> Text

-- | The column of the violated constraint
[foreignKeyColumn] :: ForeignKeyViolation -> Text

-- | The ROWID of the row with the violated foreign key constraint
[foreignKeyRowId] :: ForeignKeyViolation -> Int64

-- | Outputs all (if any) the violated foreign key constraints in the
--   database.
--   
--   The main use is to validate that no foreign key constraints were
--   broken/corrupted by anyone operating on the database with foreign keys
--   disabled. See <a>fkEnabled</a>.
checkForeignKeys :: (MonadResource m, MonadReader env m, BackendCompatible SqlBackend env) => ConduitM () ForeignKeyViolation m ()

-- | Wrapper for persistent SqlBackends that carry the corresponding
--   <a>Connection</a>.
data RawSqlite backend

-- | Open a <tt><a>RawSqlite</a> <a>SqlBackend</a></tt> connection from a
--   <a>SqliteConnectionInfo</a>.
--   
--   When using this function, the caller has to accept the responsibility
--   of cleaning up the resulting connection. To do this, use
--   <tt>close</tt> with the <a>rawSqliteConnection</a> - it's enough to
--   simply drop the <a>persistBackend</a> afterwards.
openRawSqliteConn :: (MonadUnliftIO m, MonadLoggerIO m) => SqliteConnectionInfo -> m (RawSqlite SqlBackend)
persistentBackend :: forall backend_anFd backend_at20. Lens (RawSqlite backend_anFd) (RawSqlite backend_at20) backend_anFd backend_at20
rawSqliteConnection :: forall backend_anFd. Lens' (RawSqlite backend_anFd) Connection

-- | Like <a>withSqliteConnInfo</a>, but exposes the internal
--   <a>Connection</a>. For power users who want to manually interact with
--   SQLite's C API via internals exposed by
--   <a>Database.Sqlite.Internal</a>
withRawSqliteConnInfo :: (MonadUnliftIO m, MonadLoggerIO m) => SqliteConnectionInfo -> (RawSqlite SqlBackend -> m a) -> m a

-- | Like <a>createSqlitePoolFromInfo</a>, but like
--   <a>withRawSqliteConnInfo</a> it exposes the internal
--   <a>Connection</a>.
--   
--   For power users who want to manually interact with SQLite's C API via
--   internals exposed by <a>Database.Sqlite.Internal</a>. The callback can
--   be used to run arbitrary actions on the connection upon allocation
--   from the pool.
createRawSqlitePoolFromInfo :: (MonadLoggerIO m, MonadUnliftIO m) => SqliteConnectionInfo -> (RawSqlite SqlBackend -> m ()) -> Int -> m (Pool (RawSqlite SqlBackend))

-- | Like <a>createRawSqlitePoolFromInfo</a>, but doesn't require a
--   callback operating on the connection.
createRawSqlitePoolFromInfo_ :: (MonadLoggerIO m, MonadUnliftIO m) => SqliteConnectionInfo -> Int -> m (Pool (RawSqlite SqlBackend))

-- | Like <tt>createSqlitePoolInfo</tt>, but based on
--   <a>createRawSqlitePoolFromInfo</a>.
withRawSqlitePoolInfo :: (MonadUnliftIO m, MonadLoggerIO m) => SqliteConnectionInfo -> (RawSqlite SqlBackend -> m ()) -> Int -> (Pool (RawSqlite SqlBackend) -> m a) -> m a

-- | Like <tt>createSqlitePoolInfo</tt>, but based on
--   <a>createRawSqlitePoolFromInfo_</a>.
withRawSqlitePoolInfo_ :: (MonadUnliftIO m, MonadLoggerIO m) => SqliteConnectionInfo -> Int -> (Pool (RawSqlite SqlBackend) -> m a) -> m a
instance Database.Persist.Class.PersistStore.HasPersistBackend b0 => Database.Persist.Class.PersistStore.HasPersistBackend (Database.Persist.Sqlite.RawSqlite b0)
instance (Database.Persist.Class.PersistStore.HasPersistBackend b0, Database.Persist.Class.PersistStore.PersistStoreRead b0) => Database.Persist.Class.PersistStore.PersistStoreRead (Database.Persist.Sqlite.RawSqlite b0)
instance (Database.Persist.Class.PersistStore.HasPersistBackend b0, Database.Persist.Class.PersistQuery.PersistQueryRead b0) => Database.Persist.Class.PersistQuery.PersistQueryRead (Database.Persist.Sqlite.RawSqlite b0)
instance (Database.Persist.Class.PersistStore.HasPersistBackend b0, Database.Persist.Class.PersistUnique.PersistUniqueRead b0) => Database.Persist.Class.PersistUnique.PersistUniqueRead (Database.Persist.Sqlite.RawSqlite b0)
instance (Database.Persist.Class.PersistStore.HasPersistBackend b0, Database.Persist.Class.PersistStore.PersistStoreWrite b0) => Database.Persist.Class.PersistStore.PersistStoreWrite (Database.Persist.Sqlite.RawSqlite b0)
instance (Database.Persist.Class.PersistStore.HasPersistBackend b0, Database.Persist.Class.PersistQuery.PersistQueryWrite b0) => Database.Persist.Class.PersistQuery.PersistQueryWrite (Database.Persist.Sqlite.RawSqlite b0)
instance (Database.Persist.Class.PersistStore.HasPersistBackend b0, Database.Persist.Class.PersistUnique.PersistUniqueWrite b0) => Database.Persist.Class.PersistUnique.PersistUniqueWrite (Database.Persist.Sqlite.RawSqlite b0)
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), GHC.Show.Show (Database.Persist.Class.PersistStore.BackendKey b0)) => GHC.Show.Show (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), GHC.Read.Read (Database.Persist.Class.PersistStore.BackendKey b0)) => GHC.Read.Read (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), GHC.Classes.Eq (Database.Persist.Class.PersistStore.BackendKey b0)) => GHC.Classes.Eq (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), GHC.Classes.Ord (Database.Persist.Class.PersistStore.BackendKey b0)) => GHC.Classes.Ord (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), GHC.Num.Num (Database.Persist.Class.PersistStore.BackendKey b0)) => GHC.Num.Num (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), GHC.Real.Integral (Database.Persist.Class.PersistStore.BackendKey b0)) => GHC.Real.Integral (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistStore.BackendKey b0)) => Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistStore.BackendKey b0)) => Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), GHC.Real.Real (Database.Persist.Class.PersistStore.BackendKey b0)) => GHC.Real.Real (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), GHC.Enum.Enum (Database.Persist.Class.PersistStore.BackendKey b0)) => GHC.Enum.Enum (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), GHC.Enum.Bounded (Database.Persist.Class.PersistStore.BackendKey b0)) => GHC.Enum.Bounded (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistStore.BackendKey b0)) => Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance (Database.Persist.Class.PersistStore.PersistCore b0, Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b0), Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistStore.BackendKey b0)) => Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistStore.BackendKey (Database.Persist.Sqlite.RawSqlite b0))
instance GHC.Show.Show Database.Persist.Sqlite.SqliteConnectionInfo
instance GHC.Show.Show Database.Persist.Sqlite.SqliteConf
instance GHC.Show.Show Database.Persist.Sqlite.ForeignKeyViolation
instance GHC.Classes.Ord Database.Persist.Sqlite.ForeignKeyViolation
instance GHC.Classes.Eq Database.Persist.Sqlite.ForeignKeyViolation
instance Database.Persist.Class.PersistStore.BackendCompatible b (Database.Persist.Sqlite.RawSqlite b)
instance Database.Persist.Class.PersistStore.PersistCore b => Database.Persist.Class.PersistStore.PersistCore (Database.Persist.Sqlite.RawSqlite b)
instance Data.Aeson.Types.FromJSON.FromJSON Database.Persist.Sqlite.SqliteConf
instance Database.Persist.Class.PersistConfig.PersistConfig Database.Persist.Sqlite.SqliteConf
instance Data.Aeson.Types.FromJSON.FromJSON Database.Persist.Sqlite.SqliteConnectionInfo
